#include <cpprest/http_client.h>
#include <cpprest/filestream.h>
#include <cpprest/json.h>

#include <vector>
#include <map>

#include  "../include/led-matrix.h"
#include "../include/graphics.h"

#include <Magick++.h>
#include <fcntl.h>
#include <signal.h>
#include <unistd.h>

#include <ctime>
#include <string>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <cmath>

#include "content-streamer.h"


using namespace utility; // Common utilities like string conversions
using namespace web; // Common features like URIs.
using namespace http; // Common HTTP functionality
using namespace client; // HTTP client features
using namespace concurrency::streams; // Asynchronous streams
using namespace std::chrono; // nanoseconds, system_clock, seconds
using namespace rgb_matrix;
using rgb_matrix::RGBMatrix;
using std::string;
using std::pair;
using std::chrono::seconds;
using std::chrono::system_clock;
using std::vector;
using rgb_matrix::StreamReader;
using rgb_matrix::StreamIO;
using rgb_matrix::FileStreamIO;

typedef int64_t tmillis_t;
static const tmillis_t distant_future = (1LL << 40); // that is a while.


string selectImagesToDraw(vector<int>&, vector<long long>&);
string getTemperatureToDisplay(int);
volatile bool interrupt_received = false;


/*
struct ImageParams
{
	ImageParams()
		: anim_duration_ms(distant_future)
		  , wait_ms(10000)
		  , anim_delay_ms(-1)
		  , loops(-1)
		  , vsync_multiple(1)
	{
	}

	tmillis_t anim_duration_ms; // If this is an animation, duration to show.
	tmillis_t wait_ms; // Regular image: duration to show.
	tmillis_t anim_delay_ms; // Animation delay override.
	int loops;
	int vsync_multiple;
};

struct FileInfo
{
	ImageParams params; // Each file might have specific timing settings
	bool is_multi_frame;
	StreamIO* content_stream;
};
*/
static void InterruptHandler(int signum)
{
	std::wcout << "Program exiting...." << "\n";
	interrupt_received = true;
}

long long getEpochTime()
{
	const long long timeNow = duration_cast<seconds>(system_clock::now().time_since_epoch()).count();
	return timeNow;
}

static void add_micros(struct timespec* accumulator, long micros)
{
	const long billion = 1000000000;
	const int64_t nanos = static_cast<int64_t>(micros) * 1000;
	accumulator->tv_sec += nanos / billion;
	accumulator->tv_nsec += nanos % billion;
	while (accumulator->tv_nsec > billion)
	{
		accumulator->tv_nsec -= billion;
		accumulator->tv_sec += 1;
	}
}

class requestCurrentWeather
{
private:
	json::value openWeatherJSONResponse;
	// Create http_client to send the request.
	const string_t apiKey = U("2cad0f109bdc9bde64036cb481a0a493"); //apiKey
	const string_t getRequestTempUnits = U("imperial"); //select units (standard/metric/imperial)

	int currentTemperature = 0;
	std::vector<int> arrayOfWeatherIDs;
	std::vector<long long> arrayOfTimes;
	int windSpeed = 0;
	int feelsLikeTemp = 0;

public:
	int getWeatherData()
	{
		try
		{
			// Build request URI and start the request.
			http_client client(U("http://api.openweathermap.org/data/2.5/weather?"));
			uri_builder builder;
			builder.append_query(U("id"), 5128581);
			builder.append_query(U("appid"), apiKey);
			builder.append_query(U("units"), getRequestTempUnits);
			return client.request(methods::GET, builder.to_string())
			             // Handle response headers arriving.

			             .then([= , this](http_response response)
			             {
				             if (response.status_code() == status_codes::OK)
				             {
					             //printf("Received response status code:%u\n", response.status_code());
					             openWeatherJSONResponse = response.extract_json().get();
					             json::value weather = openWeatherJSONResponse.at(U("weather"));
					             json::value main = openWeatherJSONResponse.at(U("main"));
					             json::value sys = openWeatherJSONResponse.at(U("sys"));
					             json::value wind = openWeatherJSONResponse.at(U("wind"));

					             //in the format [currentTime, sunRise, sunSet]
					             for (auto i : weather.as_array())
					             {
						             arrayOfWeatherIDs.push_back(i.at(U("id")).as_integer());
						             std::wcout << i.at(U("id")).as_integer() << "\n";
					             }

					             currentTemperature = main.at(U("temp")).as_integer();
					             feelsLikeTemp = main.at(U("feels_like")).as_integer();
					             windSpeed = wind.at(U("speed")).as_integer();
					             std::wcout << currentTemperature << "\n";
					             int64_t sunrise = sys.at(U("sunrise")).as_number().to_int64();
					             int64_t sunset = sys.at(U("sunset")).as_number().to_int64();
					             std::wcout << sunrise << "\n";
					             std::wcout << sunset << "\n";
					             arrayOfTimes.push_back(getEpochTime());
					             arrayOfTimes.push_back(sunrise);
					             arrayOfTimes.push_back(sunset);
					             sleep(5);
				             }
			             }).wait();
		}

			// Wait for all the outstanding I/O to complete and handle any exceptions

		catch (const std::exception& e)
		{
			std::wcout << e.what();
			return 1;
		}
	}

	int getCurrentTemperature() const
	{
		return currentTemperature;
	}

	vector<int> getWeatherIDArray() const
	{
		return arrayOfWeatherIDs;
	}

	int getWindSpeed() const
	{
		return windSpeed;
	}

	int getFeelsLikeTemp() const
	{
		return feelsLikeTemp;
	}

	vector<long long> getTimeArray() const
	{
		return arrayOfTimes;
	}
};

class WindowCanvas : public Canvas
{
public:
	WindowCanvas(Canvas* delegatee,
	             int width,
	             int height,
	             int offset_x,
	             int offset_y)
		: delegatee_(delegatee)
		  , width_(width)
		  , height_(height)
		  , offset_x_(offset_x)
		  , offset_y_(offset_y)
	{
	}

	int width() const override { return width_; }
	int height() const override { return height_; }

	void SetPixel(int x, int y, uint8_t r, uint8_t g, uint8_t b) override
	{
		if (x < 0 || x > width_ || y < 0 || y > height_) return; // do clipping
		delegatee_->SetPixel(x + offset_x_, y + offset_y_, r, g, b);
	}

	void Clear() override { delegatee_->Clear(); }

	void Fill(uint8_t r, uint8_t g, uint8_t b) override
	{
		delegatee_->Fill(r, g, b);
	}

private:
	Canvas* const delegatee_;
	const int width_;
	const int height_;
	const int offset_x_;
	const int offset_y_;
};

vector<string> lookUpImageToDraw(vector<int>& weatherID)
{
	std::map<int, string> weatherCodeDict;
	weatherCodeDict.insert(pair<int, string>(200, "tStorm-1"));
	weatherCodeDict.insert(pair<int, string>(201, "tStorm-7"));
	weatherCodeDict.insert(pair<int, string>(202, "tStorm-8"));
	weatherCodeDict.insert(pair<int, string>(210, "tStorm-1"));
	weatherCodeDict.insert(pair<int, string>(211, "tStorm-2"));
	weatherCodeDict.insert(pair<int, string>(212, "tStorm-8"));
	weatherCodeDict.insert(pair<int, string>(221, "tStorm-9"));
	weatherCodeDict.insert(pair<int, string>(230, "tStorm-1"));
	weatherCodeDict.insert(pair<int, string>(231, "tStorm-7"));
	weatherCodeDict.insert(pair<int, string>(232, "tStorm-8"));
	weatherCodeDict.insert(pair<int, string>(300, "rainy-1"));
	weatherCodeDict.insert(pair<int, string>(301, "rainy-2"));
	weatherCodeDict.insert(pair<int, string>(302, "rainy-3"));
	weatherCodeDict.insert(pair<int, string>(310, "rainy-1"));
	weatherCodeDict.insert(pair<int, string>(311, "rainy-2"));
	weatherCodeDict.insert(pair<int, string>(312, "rainy-3"));
	weatherCodeDict.insert(pair<int, string>(313, "rainy-2"));
	weatherCodeDict.insert(pair<int, string>(314, "rainy-3"));
	weatherCodeDict.insert(pair<int, string>(321, "rainy-2"));
	weatherCodeDict.insert(pair<int, string>(500, "rainy-7"));
	weatherCodeDict.insert(pair<int, string>(501, "rainy-4"));
	weatherCodeDict.insert(pair<int, string>(502, "rainy-5"));
	weatherCodeDict.insert(pair<int, string>(503, "rainy-6"));
	weatherCodeDict.insert(pair<int, string>(504, "rainy-6"));
	weatherCodeDict.insert(pair<int, string>(511, "hail-1"));
	weatherCodeDict.insert(pair<int, string>(520, "rainy-7"));
	weatherCodeDict.insert(pair<int, string>(521, "rainy-4"));
	weatherCodeDict.insert(pair<int, string>(522, "rainy-5"));
	weatherCodeDict.insert(pair<int, string>(531, "rainy-5"));
	weatherCodeDict.insert(pair<int, string>(600, "snow-1"));
	weatherCodeDict.insert(pair<int, string>(601, "snow-2"));
	weatherCodeDict.insert(pair<int, string>(602, "snow-4"));
	weatherCodeDict.insert(pair<int, string>(611, "sleet-1"));
	weatherCodeDict.insert(pair<int, string>(612, "sleet-1"));
	weatherCodeDict.insert(pair<int, string>(613, "sleet-1"));
	weatherCodeDict.insert(pair<int, string>(615, "sleet-1"));
	weatherCodeDict.insert(pair<int, string>(616, "sleet-1"));
	weatherCodeDict.insert(pair<int, string>(620, "sleet-1"));
	weatherCodeDict.insert(pair<int, string>(621, "sleet-1"));
	weatherCodeDict.insert(pair<int, string>(622, "sleet-1"));
	weatherCodeDict.insert(pair<int, string>(701, "foggy-1"));
	weatherCodeDict.insert(pair<int, string>(711, "foggy-1"));
	weatherCodeDict.insert(pair<int, string>(721, "foggy-2"));
	weatherCodeDict.insert(pair<int, string>(731, "foggy-2"));
	weatherCodeDict.insert(pair<int, string>(741, "foggy-2"));
	weatherCodeDict.insert(pair<int, string>(751, "foggy-2"));
	weatherCodeDict.insert(pair<int, string>(761, "foggy-2"));
	weatherCodeDict.insert(pair<int, string>(762, "foggy-2"));
	weatherCodeDict.insert(pair<int, string>(771, "foggy-2"));
	weatherCodeDict.insert(pair<int, string>(781, "tornado"));
	weatherCodeDict.insert(pair<int, string>(800, "clear"));
	weatherCodeDict.insert(pair<int, string>(801, "cloudy-2"));
	weatherCodeDict.insert(pair<int, string>(802, "cloudy-2"));
	weatherCodeDict.insert(pair<int, string>(803, "cloudy-3"));
	weatherCodeDict.insert(pair<int, string>(804, "cloudy-3"));

	vector<string> fileNames;

	for (auto i : weatherID)
	{
		auto it = weatherCodeDict.find(i);
		fileNames.push_back(it->second); //retrieve array of image file names to be displayed
	}

	return fileNames;
}

string getTemperatureToDisplay(int temp)
{
	string temperature = std::to_string(temp);
	string a = "Current Temperature: ";
	string output = a.append(temperature);
	std::wcout << "im alive";
	std::wcout << output.c_str() << "\n";
	return output;
}

string selectImagesToDraw(vector<int>& weatherID, vector<long long>& times)
//pass by reference an integer array [ [weatherCodes], [weatherID, currentTime, sunRise, sunSet, currentTemp]]

{
	//this function appends the proper directory to the image file path 
	const long long currentTime = times[0];
	const long long sunRise = times[1];
	const long long sunSet = times[2];
	vector<string> filesToDraw = lookUpImageToDraw(weatherID);
	string imageFilePath;

	for (auto i : filesToDraw)
	{
		if ((currentTime > sunRise) && (currentTime < sunSet))
		{
			// it is daytime, use the daytime icon folder path
			imageFilePath = "./weatherIcons/dayIcons/";

			return imageFilePath.append(i);
		}
		//it is night, use nighttime icon folder path
		imageFilePath = "./weatherIcons/nightIcons/";

		return imageFilePath.append(i);
	}
}

/*

static void StoreInStream(const Magick::Image& img,
                          int delay_time_us,
                          bool do_center,
                          FrameCanvas* scratch,
                          StreamWriter* output)
                          {
	                          scratch->Clear();
	                          const int x_offset = do_center ? (scratch->width() - img.columns()) / 2 : 0;
	                          const int y_offset = do_center ? (scratch->height() - img.rows()) / 2 : 0;
	                          for (size_t y = 0; y < img.rows(); ++y)
	                          {
		                          for (size_t x = 0; x < img.columns(); ++x)
		                          {
			                          const Magick::Color& c = img.pixelColor(x, y);
			                          if (c.alphaQuantum() < 256)
			                          {
				                          scratch->SetPixel(x + x_offset,
				                                            y + y_offset,
				                                            ScaleQuantumToChar(c.redQuantum()),
				                                            ScaleQuantumToChar(c.greenQuantum()),
				                                            ScaleQuantumToChar(c.blueQuantum()));
				                                         }
			                                         }
											   }
											   output->Stream(*scratch, delay_time_us);
											   }

											   static void CopyStream(StreamReader* r,
											                          StreamWriter* w,
											                          FrameCanvas* scratch)
											                          {
												                          uint32_t delay_us;
												                          while (r->GetNext(scratch, &delay_us))
												                          {
													                          w->Stream(*scratch, delay_us);
												                          }
												                          }
												                          */
int main(int argc, char* argv[])
{
	Magick::InitializeMagick(*argv);
	RGBMatrix::Options canvasOptions;
	RuntimeOptions runtime_options;
	requestCurrentWeather currentWeather;
	canvasOptions.hardware_mapping = "adafruit-hat";
	canvasOptions.rows = 64;
	canvasOptions.cols = 64;
	canvasOptions.chain_length = 1;
	canvasOptions.parallel = 1;
	canvasOptions.row_address_type = 0;
	canvasOptions.multiplexing = 0;
	runtime_options.gpio_slowdown = 0;


	Color textColor(255, 255, 255);
	Color bg_color(0, 0, 0);
	Color outline_color(0, 0, 0);
	bool with_outline = false;
	const char* bdf_font_file = "./font/spleen-5x8.bdf";
	bool xorigin_configured = false;
	int x_orig = 0;
	int y_orig = 10;
	int letter_spacing = 0;
	float speed = 10.0f;
	int loops = -1;
	int blink_on = 0;
	int blink_off = 0;

	//bool do_forever = false;
	//bool do_center = false;
	//bool do_shuffle = false;

	//StreamIO* stream_io = nullptr;
	//StreamWriter* global_stream_writer = nullptr;

	Font font;
	Font* outline_font = nullptr;
	if (!font.LoadFont(bdf_font_file))
	{
		fprintf(stderr, "Couldn't load font '%s'\n", bdf_font_file);
		return 1;
	}

	RGBMatrix* canvas = RGBMatrix::CreateFromOptions(canvasOptions, runtime_options);
	FrameCanvas* offscreenCanvas = canvas->CreateFrameCanvas();


	//Canvas* textWindow = new WindowCanvas(offscreenCanvas, 64, 8, 0, 0);
	//Canvas* imageWindow = new WindowCanvas(offscreenCanvas, 64, 56, 0, 0);

	if (canvas == nullptr)
	{
		return 1;
	}
	signal(SIGTERM, InterruptHandler);
	signal(SIGINT, InterruptHandler);


	/*
	std::vector<FileInfo*> file_imgs;
	std::map<const void*, struct ImageParams> filename_params;
	ImageParams img_param;

	for (int i = 0; i < argc; ++i)
	{
		filename_params[argv[i]] = img_param;
	}


	const bool fill_width = false;
	const bool fill_height = false;

	for (int imgarg = optind; imgarg < argc; ++imgarg)
	{
		const char* filename = argv[imgarg];
		FileInfo* file_info = nullptr;

		std::string err_msg;
		std::vector<Magick::Image> image_sequence;
		if (LoadImageAndScale(filename,
		                      canvas->width(),
		                      canvas->height(),
		                      fill_width,
		                      fill_height,
		                      &image_sequence,
		                      &err_msg))
		                    {
			                    file_info = new FileInfo();
			                    file_info->params = filename_params[filename];
			                    file_info->content_stream = new MemStreamIO();
			                    file_info->is_multi_frame = image_sequence.size() > 1;
			                    StreamWriter out(file_info->content_stream);
			                    for (size_t i = 0; i < image_sequence.size(); ++i)
			                    {
				                    const Magick::Image& img = image_sequence[i];
				                    int64_t delay_time_us;
				                    if (file_info->is_multi_frame)
				                    {
					                    delay_time_us = img.animationDelay() * 10000; // unit in 1/100s
				                    }
				                    else
				                    {
					                    delay_time_us = file_info->params.wait_ms * 1000; // single image.
	                    }
	                    if (delay_time_us <= 0) delay_time_us = 100 * 1000; // 1/10sec
	                    StoreInStream(img,
	                                  delay_time_us,
	                                  do_center,
	                                  offscreenCanvas,
	                                  global_stream_writer ? global_stream_writer : &out);
	                               }
                               }
                               else
                               {
	                               // Ok, not an image. Let's see if it is one of our streams.
	                               int fd = open(filename, O_RDONLY);
	                               if (fd >= 0)
	                               {
		                               file_info = new FileInfo();
		                               file_info->params = filename_params[filename];
		                               file_info->content_stream = new FileStreamIO(fd);
		                               StreamReader reader(file_info->content_stream);
		                               if (reader.GetNext(offscreenCanvas, nullptr))
		                               {
			                               // header+size ok
			                               file_info->is_multi_frame = reader.GetNext(offscreenCanvas, nullptr);
			                               reader.Rewind();
			                               if (global_stream_writer)
			                               {
				                               CopyStream(&reader, global_stream_writer, offscreenCanvas);
			                               }
                           }
                           else
                           {
                               err_msg = "Can't read as image or compatible stream";
                               delete file_info->content_stream;
                               delete file_info;
                               file_info = nullptr;
						}
			}
			else
			{
				perror("Opening file");
	}
}

if (file_info)
{
file_imgs.push_back(file_info);
}
else
{
fprintf(stderr,
        "%s skipped: Unable to open (%s)\n",
        filename,
        err_msg.c_str());
      }
  }

  */
/*
	const int scroll_direction = (speed >= 0) ? -1 : 1;
	speed = fabs(speed);
	int delay_speed_usec = 1000000;
	if (speed > 0)
	{
		delay_speed_usec = 1000000 / speed / font.CharacterWidth('W');
		//delay_speed_usec = 10;
	}

	if (!xorigin_configured)
	{
		if (speed == 0)
		{
			// There would be no scrolling, so text would never appear. Move to front.
			x_orig = with_outline ? 1 : 0;
		}
		else
		{
			x_orig = scroll_direction < 0 ? canvas->width() : 0;
		}
	}

	int x = x_orig;
	int y = y_orig;
	int length = 0;

	struct timespec next_frame = {0, 0};

	unsigned int frame_counter = 0;
	while (!interrupt_received && loops != 0)
	{
		//std::wcout << frame_counter;
		currentWeather.getWeatherData();
		std::string line = getTemperatureToDisplay(currentWeather.getCurrentTemperature());
		++frame_counter;
		offscreenCanvas->Fill(bg_color.r, bg_color.g, bg_color.b);
		const bool draw_on_frame = (blink_on <= 0)
			|| (frame_counter % (blink_on + blink_off) < static_cast<unsigned>(blink_on));

		if (draw_on_frame)
		{
			if (outline_font)
			{
				// The outline font, we need to write with a negative (-2) text-spacing,
				// as we want to have the same letter pitch as the regular text that
				// we then write on top.
				DrawText(offscreenCanvas,
				         *outline_font,
				         x - 1,
				         y + font.baseline(),
				         outline_color,
				         nullptr,
				         line.c_str(),
				         letter_spacing - 2);
			}

			// length = holds how many pixels our text takes up
			length = DrawText(offscreenCanvas,
			                  font,
			                  x,
			                  y + font.baseline(),
			                  textColor,
			                  nullptr,
			                  line.c_str(),
			                  letter_spacing);
		}

		x += scroll_direction;
		if ((scroll_direction < 0 && x + length < 0) ||
			(scroll_direction > 0 && x > canvas->width()))
		{
			x = x_orig + ((scroll_direction > 0) ? -length : 0);
			if (loops > 0) --loops;
		}


		// Make sure render-time delays are not influencing scroll-time
		if (speed > 0)
		{
			if (next_frame.tv_sec == 0)
			{
				// First time. Start timer, but don't wait. 
				clock_gettime(CLOCK_MONOTONIC, &next_frame);
			}
			else
			{
				add_micros(&next_frame, delay_speed_usec);
				clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &next_frame, nullptr);
			}
		}
		// Swap the offscreen_canvas with canvas on vsync, avoids flickering
		offscreenCanvas = canvas->SwapOnVSync(offscreenCanvas);
		if (speed <= 0) pause(); // Nothing to scroll.
	} */

	// Finished. Shut down the RGB matrix.
	canvas->Clear();
	delete canvas;
	return 0;
}
